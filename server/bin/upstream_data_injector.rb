#!/usr/bin/env ruby

# Upstream data injector
# Loads data information into the Candlepin HostedTest adapter for upstream/hosted testing.
#
# - The provided json files are expected to be an object or array of objects
# - If the subscription does not define an ID, one will be generated for it; products must have
#   a valid ID defined
# - Children objects defined on the upstream data will be automatically generated as necessary
# - Upstream data arrays can be generated by enabling TRACE level logging for an owner and
#   running refresh in hosted

require 'optparse'
require 'json'
require 'digest'
require 'zlib'

require_relative "../client/ruby/candlepin_api"



@options = {}

def log(message)
    puts message unless @options[:silent]
end

def terminate(message)
    $stderr.puts "ERROR: #{message}"
    exit
end

def generate_subscription_id(filename, index, subscription)
    sid = Digest::MD5.hexdigest "#{filename}.#{index}"

    log("Generated ID for subscription \##{index} from #{filename}: #{sid}")
    return sid
end

# Checks that Candlepin is running in standalone mode with the hosted test adapter
def check_candlepin_configuration(candlepin)
    status = candlepin.get_status()
    standalone = (status['standalone'].to_s.downcase == 'true')

    terminate("Cannot inject upstream data; Candlepin is running in standalone mode") if standalone

    hosted_adapter = false

    begin
        response = candlepin.get('/hostedtest/alive', {}, 'text/plain', true)
        hosted_adapter = (response.to_s.downcase == 'true')
    rescue RestClient::ResourceNotFound
        # CP running without the Hosted adapter
    end

    terminate("Cannot inject upstream data; Hosted adapter is absent or disabled") if !hosted_adapter
end

# verify target organization exists, creating it as necessary
def ensure_organization_exists(candlepin, owner_key)
    begin
        owner = candlepin.get_owner(owner_key)
    rescue RestClient::ResourceNotFound
        log("Owner #{owner_key} does not exist; creating it...")
        owner = candlepin.create_owner(owner_key)
    end

    return owner
end

# Reads the subscriptions from the given file and loads them
def stream_json_objects(filename, &block)
    begin
        # open file
        json_file = filename.end_with?('.gz') ?
            Zlib::GzipReader.open(filename) :
            File.open(filename)

        offset = 0
        token_stack = []
        json_buffer = ""
        capture = false
        dispatch = false

        while !json_file.eof?
            char = json_file.getc()
            retain_last = true
            offset += 1

            if token_stack.last == '\\'
                token_stack.pop
            elsif ['\'', '"'].include?(token_stack.last)
                if char == token_stack.last
                    token_stack.pop
                elsif char == '\\'
                    token_stack.push(char)
                end
            else
                case char
                    when '{'
                        token_stack.push(char)
                        capture = true

                    when '}'
                        if token_stack.pop() != '{'
                            terminate("JSON parsing error: unexpected obj_end at offset #{offset}")
                        end

                        dispatch = token_stack.empty? || (token_stack.length == 1 && token_stack.last == '[')

                    when '['
                        token_stack.push(char)

                    when ']'
                        if token_stack.pop() != '['
                            terminate("JSON parsing error: unexpected arr_end at offset #{offset}")
                        end

                    when '"'
                        token_stack.push(char)

                    when '\''
                        token_stack.push(char)

                    when nil
                        if !token_stack.empty?
                            terminate("JSON parsing error: unexpected EOF")
                        end
                end
            end

            json_buffer << char if capture

            if dispatch
                object = JSON.parse(json_buffer)
                block.call(object) if block

                json_buffer = ""
                capture = false
                dispatch = false
            end
        end
    rescue Exception => e
        pp e

        terminate("Unable to parse provided JSON file: #{filename}\n"\
            "Ensure the file is readable and is a JSON-formatted object or array of JSON objects")
    end
end

def clear_upstream_data(candlepin)
  candlepin.delete('/hostedtest', {}, nil, true)
end

# Creates the given subscription in Candlepin's upstream data store, updating it if it already exists
def store_upstream_subscription(candlepin, subscription_id, params = {})
    start_date = params.delete(:start_date) || Date.today
    end_date = params.delete(:end_date) || start_date + 365

    # Define subscription with defaults & specified params
    subscription = {
        'startDate' => start_date,
        'endDate'   => end_date,
        'quantity'  => 1
    }

    # Do not copy these with the rest of the merged keys
    filter = ['id', 'ownerId']

    params.each do |key, value|
        # Convert the key to snake case so we can support whatever is thrown at us
        key = key.to_s.gsub(/_(\w)/){$1.upcase}

        if !filter.include?(key)
            subscription[key] = value
        end
    end

    # Forcefully set critical identifiers
    subscription['id'] = subscription_id

    # if the sub is using the old-style ID-based owner reference, convert it
    if (!subscription.key?('owner') && params['ownerId'])
        subscription['owner'] = { :key => params['ownerId'] }
    end

    # Create or update subscription in our upstream store
    qparams = {'create_children' => 'true'}
    begin
        output = candlepin.post('hostedtest/subscriptions', qparams, subscription)
    rescue RestClient::Conflict
        log("  Subscription #{subscription['id']} already exists; updating existing entry")
        output = candlepin.put("hostedtest/subscriptions/#{subscription['id']}", qparams, subscription)
    end

    return output
end

def store_upstream_product(candlepin, product_id, params = {})
    product = {
      'multiplier' => 1
    }

    # Do not copy these with the rest of the merged keys
    filter = ['id']

    params.each do |key, value|
      # Convert the key to snake case so we can support whatever is thrown at us
      key = key.to_s.gsub(/_(\w)/){$1.upcase}

      if !filter.include?(key)
        product[key] = value
      end
    end

    # Forcefully set identifier and name (if absent)
    product['id'] = product_id
    product['name'] = product_id if !product['name']

    # Create or update subscription in our upstream store
    qparams = {'create_children' => 'true'}
    begin
        output = candlepin.post('hostedtest/products', qparams, product)
    rescue RestClient::Conflict
        log("  Product #{product['id']} already exists; updating existing entry")
        output = candlepin.put("hostedtest/products/#{product['id']}", qparams, product)
    end

    return output
end

# Set up the CLI options
@options = {}
optparse = OptionParser.new do |opts|
    file = File.basename(__FILE__)
    opts.banner = "Usage: #{file} [options] json_file [json_file_2 [json_file_3 [...]]]\n\nOptions:"

    @options[:user] = 'admin'
    opts.on('--username [USER]', 'Username to connect with; defaults to "admin".') do |opt|
        @options[:user] = opt
    end

    @options[:password] = 'admin'
    opts.on('--password [PASSWORD]', 'Password to authenticate the user with; defaults to "admin".') do |opt|
        @options[:password] = opt
    end

    @options[:server] = 'localhost'
    opts.on('--server [SERVERNAME]', String, 'Server FQDN; defaults to "localhost"') do |opt|
        @options[:server] = opt
    end

    @options[:port] = 8443
    opts.on('--port [PORTNUM]', 'Port number for the Candlepin server; defaults to 8443') do |opt|
        @options[:port] = opt.to_i
    end

    @options[:context] = 'candlepin'
    opts.on('--context [CONTEXT]', 'Context to use for the Candlepin connection; defaults to "candlepin"') do |opt|
        @options[:context] = opt
    end

    @options[:uuid] = nil
    opts.on('--uuid [UUID]', 'UUID to use for the Candlepin connection; defaults to nil') do |opt|
        @options[:uuid] = opt
    end

    @options[:ssl] = true
    opts.on('--nossl', 'Do not use SSL; defaults to false') do
        @options[:ssl] = false
    end

    @options[:trusted_user] = false
    opts.on('--trusted', 'If the Candlepin user should be trusted; defaults to false') do
        @options[:trusted_user] = true
    end

    @options[:clean] = false
    opts.on('--clean', 'Clears the upstream subscription data before injecting the new data') do
        @options[:clean] = true
    end

    @options[:silent] = false
    opts.on('--silent', 'Disable output while generating consumers' ) do
        @options[:silent] = true
    end

    @options[:type] = 'subscriptions'
    opts.on('--type [TYPE]', String, 'Specifies the type of data represented by the provided JSON files; defaults to "subscriptions"') do |opt|
        @options[:type] = opt
    end

    opts.on('-?', '--help', 'Displays command and option information') do
        puts opts
        exit
    end
end

optparse.parse!

candlepin = Candlepin.new(
    @options[:user], @options[:password], nil, nil, @options[:server], @options[:port], nil,
    @options[:uuid], @options[:trused_user], @options[:context], @options[:ssl])

if ARGV.length < 1
    log(optparse)
    exit
end

# Determine the type of operation we'll need here
type = @options[:type].downcase
op_block = nil
count = 0

case type
    when 'sub', 'subs', 'subscription', 'subscriptions'
        op_block = proc { |subscription|
            sid = subscription['id']
            sid = generate_subscription_id(json_file, count, subscription) if !sid

            count += 1
            log("Persisting data for subscription ##{count}: #{sid}")
            created = store_upstream_subscription(candlepin, sid, subscription)
        }

    when 'prod', 'product', 'products'
        op_block = proc { |product|
            pid = product['id']

            count += 1
            log("Persisting data for product ##{count}: #{pid}")
            created = store_upstream_product(candlepin, pid, product)
        }

    else
        terminate("Unknown data type: #{type}\n")
end

# Verify we're targeting a Candlepin with the hosted test bits enabled
check_candlepin_configuration(candlepin)

# Check if we need to clean the upstream data first
if @options[:clean]
    log("Clearing existing upstream data")
    clear_upstream_data(candlepin)
end

# Inject subscriptions from all files provided
total = 0

ARGV.each do |json_file|
    log("Loading data from file #{json_file}...")

    count = 0
    stream_json_objects(json_file, &op_block)
    total = total + count
end

log("Finished!")
log("Persisted #{total} objects")
