#!/usr/bin/env ruby
# Upstream subscription injector
# Loads subscription information into the Candlepin HostedTest adapter for testing.
#
# - The provided json files are expected to be a subscription object or array of subscription
#   objects
# - If the subscription does not define an ID, one will be generated for it
# - Any owner defined on the subscriptions will be ignored and overwritten with one generated
#   for the owner key given at runtime
# - Upstream subscription arrays can be generated by enabling TRACE level logging for an owner
#   during refresh in hosted

require 'optparse'
require 'json'
require 'digest'
require 'zlib'

require_relative "../client/ruby/candlepin_api"



@options = {}

def log(message)
    puts message unless @options[:silent]
end

def terminate(message)
    $stderr.puts "ERROR: #{message}"
    exit
end

def generate_subscription_id(filename, index, subscription)
    sid = Digest::MD5.hexdigest "#{filename}.#{index}"

    log("Generated ID for subscription \##{index} from #{filename}: #{sid}")
    return sid
end

# Checks that Candlepin is running in standalone mode with the hosted test adapter
def check_candlepin_configuration(candlepin)
    status = candlepin.get_status()
    standalone = (status['standalone'].to_s.downcase == 'true')

    terminate("Cannot inject upstream data; Candlepin is running in standalone mode") if standalone

    hosted_adapter = false

    begin
        response = candlepin.get('/hostedtest/alive', {}, 'text/plain', true)
        hosted_adapter = (response.to_s.downcase == 'true')
    rescue RestClient::ResourceNotFound
        # CP running without the Hosted adapter
    end

    terminate("Cannot inject upstream data; Hosted adapter is absent or disabled") if !hosted_adapter
end

# verify target organization exists, creating it as necessary
def ensure_organization_exists(candlepin, owner_key)
    begin
        owner = candlepin.get_owner(owner_key)
    rescue RestClient::ResourceNotFound
        log("Owner #{owner_key} does not exist; creating it...")
        owner = candlepin.create_owner(owner_key)
    end

    return owner
end

# Reads the subscriptions from the given file and loads them
def load_subscriptions(filename, &block)
    begin
        # open file
        json_file = filename.end_with?('.gz') ?
            Zlib::GzipReader.open(filename) :
            File.open(filename)

        offset = 0
        token_stack = []
        json_buffer = ""
        capture = false
        dispatch = false

        while !json_file.eof?
            char = json_file.getc()
            retain_last = true
            offset += 1

            if token_stack.last == '\\'
                token_stack.pop
            elsif ['\'', '"'].include?(token_stack.last)
                if char == token_stack.last
                    token_stack.pop
                elsif char == '\\'
                    token_stack.push(char)
                end
            else
                case char
                    when '{'
                        token_stack.push(char)
                        capture = true

                    when '}'
                        if token_stack.pop() != '{'
                            terminate("JSON parsing error: unexpected obj_end at offset #{offset}")
                        end

                        dispatch = token_stack.empty? || (token_stack.length == 1 && token_stack.last == '[')

                    when '['
                        token_stack.push(char)

                    when ']'
                        if token_stack.pop() != '['
                            terminate("JSON parsing error: unexpected arr_end at offset #{offset}")
                        end

                    when '"'
                        token_stack.push(char)

                    when '\''
                        token_stack.push(char)

                    when nil
                        if !token_stack.empty?
                            terminate("JSON parsing error: unexpected EOF")
                        end
                end
            end

            json_buffer << char if capture

            if dispatch
                subscription = JSON.parse(json_buffer)
                block.call(subscription) if block

                json_buffer = ""
                capture = false
                dispatch = false
            end
        end
    rescue
        terminate("Unable to parse provided subscription file: #{filename}\n"\
            "Ensure the file is readable and is a JSON-formatted subscription or array of subscriptions")
    end
end

def clear_upstream_data(candlepin)
  candlepin.delete('/hostedtest', {}, nil, true)
end

# Creates the given subscription in Candlepin's upstream data store, updating it if it already exists
def create_upstream_subscription(candlepin, subscription_id, params = {})
    start_date = params.delete(:start_date) || Date.today
    end_date = params.delete(:end_date) || start_date + 365

    # Define subscription with defaults & specified params
    subscription = {
        'startDate' => start_date,
        'endDate'   => end_date,
        'quantity'  => 1
    }

    # Do not copy these with the rest of the merged keys
    filter = ['id', 'ownerId']

    params.each do |key, value|
        # Convert the key to snake case so we can support whatever is thrown at us
        key = key.to_s.gsub(/_(\w)/){$1.upcase}

        if !filter.include?(key)
            subscription[key] = value
        end
    end

    # Forcefully set critical identifiers
    subscription['id'] = subscription_id

    # if the sub is using the old-style ID-based owner reference, convert it
    if (!subscription.key?('owner') && params['ownerId'])
        subscription['owner'] = { :key => params['ownerId'] }
    end

    # Create or update subscription in our upstream store
    begin
        output = candlepin.post('hostedtest/subscriptions', {}, subscription)
    rescue RestClient::Conflict
        log("  Subscription #{subscription['id']} already exists; updating existing entry")
        output = candlepin.put("hostedtest/subscriptions/#{subscription['id']}", {}, subscription)
    end

    return output
end


# Set up the CLI options
@options = {}
optparse = OptionParser.new do |opts|
    file = File.basename(__FILE__)
    opts.banner = "Usage: #{file} [options] json_file [json_file_2 [json_file_3 [...]]]\n\nOptions:"

    @options[:user] = 'admin'
    opts.on('--username [USER]', 'Username to connect with; defaults to "admin".') do |opt|
        @options[:user] = opt
    end

    @options[:password] = 'admin'
    opts.on('--password [PASSWORD]', 'Password to authenticate the user with; defaults to "admin".') do |opt|
        @options[:password] = opt
    end

    @options[:server] = 'localhost'
    opts.on('--server [SERVERNAME]', String, 'Server FQDN; defaults to "localhost"') do |opt|
        @options[:server] = opt
    end

    @options[:port] = 8443
    opts.on('--port [PORTNUM]', 'Port number for the Candlepin server; defaults to 8443') do |opt|
        @options[:port] = opt.to_i
    end

    @options[:context] = 'candlepin'
    opts.on('--context [CONTEXT]', 'Context to use for the Candlepin connection; defaults to "candlepin"') do |opt|
        @options[:context] = opt
    end

    @options[:uuid] = nil
    opts.on('--uuid [UUID]', 'UUID to use for the Candlepin connection; defaults to nil') do |opt|
        @options[:uuid] = opt
    end

    @options[:ssl] = true
    opts.on('--nossl', 'Do not use SSL; defaults to false') do
        @options[:ssl] = false
    end

    @options[:trusted_user] = false
    opts.on('--trusted', 'If the Candlepin user should be trusted; defaults to false') do
        @options[:trusted_user] = true
    end

    @options[:clean] = false
    opts.on('--clean', 'Clears the upstream subscription data before injecting the new data') do
        @options[:clean] = true
    end

    @options[:silent] = false
    opts.on('--silent', 'Disable output while generating consumers' ) do
        @options[:silent] = true
    end

    @options[:create_orgs] = false
    opts.on('--create_orgs', 'Ensure the organizations for all subscriptions exist in Candlepin, creating them as necessary; defaults to false') do
        @options[:create_orgs] = true
    end

    opts.on('-?', '--help', 'Displays command and option information') do
        puts opts
        exit
    end
end

optparse.parse!

candlepin = Candlepin.new(
    @options[:user], @options[:password], nil, nil, @options[:server], @options[:port], nil,
    @options[:uuid], @options[:trused_user], @options[:context], @options[:ssl])

check_candlepin_configuration(candlepin)

if ARGV.length < 1
    log(optparse)
    exit
end

# If we need to clean the upstream subscription first
if @options[:clean]
    log("Clearing existing upstream subscription data")
    clear_upstream_data(candlepin)
end

# Inject subscriptions from all files provided
total = 0
owner_cache = {}

ARGV.each do |json_file|
    log("Loading subscriptions from file #{json_file}...")

    count = 0

    # load & inject subscriptions
    load_subscriptions(json_file) do |subscription|
        sid = subscription['id']
        sid = generate_subscription_id(json_file, count, subscription) if !sid

        count += 1
        log("Persisting data for subscription ##{count}: #{sid}")
        created = create_upstream_subscription(candlepin, sid, subscription)

        # Check if we should create the org
        owner_key = created['owner']['key']
        if @options[:create_orgs] && !owner_cache.key?(owner_key)
            owner = ensure_organization_exists(candlepin, owner_key)
            owner_cache[owner_key] = owner
        end
    end

    total = total + count
end

log("Finished!")
log("Persisted #{total} subscriptions")
