From 9e6d3af67bde2c5785d951142022ac5ecf428592 Mon Sep 17 00:00:00 2001
From: sbakaj <sbakaj@redhat.com>
Date: Tue, 15 Jul 2025 23:12:36 +0200
Subject: [PATCH] CANDLEPIN-1030: Implemented consumer feed endpoint

---
 api/candlepin-api-spec.yaml                   | 118 +++++
 .../org/candlepin/model/ConsumerFeed.java     | 198 +++++++++
 .../model/HypervisorGuestMapping.java         |  23 +
 .../org/candlepin/model/InstalledProduct.java |  20 +
 .../candlepin/model/RhsmApiCompatCurator.java | 416 ++++++++++++++++++
 .../resource/RhsmApiCompatResource.java       |  97 ++++
 .../util/ConsumerFeedFactExtractor.java       | 104 +++++
 .../model/RhsmApiCompatCuratorTest.java       | 271 ++++++++++++
 .../candlepin/test/DatabaseTestFixture.java   |   3 +
 .../util/ConsumerFeedFactExtractorTest.java   | 160 +++++++
 10 files changed, 1410 insertions(+)
 create mode 100644 src/main/java/org/candlepin/model/ConsumerFeed.java
 create mode 100644 src/main/java/org/candlepin/model/HypervisorGuestMapping.java
 create mode 100644 src/main/java/org/candlepin/model/InstalledProduct.java
 create mode 100644 src/main/java/org/candlepin/model/RhsmApiCompatCurator.java
 create mode 100644 src/main/java/org/candlepin/resource/RhsmApiCompatResource.java
 create mode 100644 src/main/java/org/candlepin/util/ConsumerFeedFactExtractor.java
 create mode 100644 src/test/java/org/candlepin/model/RhsmApiCompatCuratorTest.java
 create mode 100644 src/test/java/org/candlepin/util/ConsumerFeedFactExtractorTest.java

diff --git a/api/candlepin-api-spec.yaml b/api/candlepin-api-spec.yaml
index edb4d4695..77ce2faee 100644
--- a/api/candlepin-api-spec.yaml
+++ b/api/candlepin-api-spec.yaml
@@ -8669,6 +8669,77 @@ paths:
         default:
           $ref: '#/components/responses/default'
 
+  /rhsmapi/owners/{org_key}/consumer_feed:
+    get:
+      description: |
+        A super-admin-only endpoint to retrieve consumer feed information for a specific owner.
+        This endpoint is deprecated and maintained only for compatibility with RHSM API.
+      tags:
+        - rhsmapi
+      operationId: getConsumerFeed
+      deprecated: true
+      parameters:
+        - name: org_key
+          in: path
+          required: true
+          schema:
+            type: string
+        - name: after_id
+          in: query
+          description: |
+            An optional string value indicating a consumer ID to use for filtering.
+            Deprecated, use after_uuid or after_checkin instead.
+          schema:
+            type: string
+        - name: after_uuid
+          in: query
+          description: |
+            An optional UUID indicating a consumer UUID to use for filtering.
+          schema:
+            type: string
+        - name: after_checkin
+          in: query
+          description: |
+            An optional ISO8601-formatted timestamp used to filter consumers based on their last check-in.
+          schema:
+            type: string
+            format: date-time
+        - $ref: "#/components/parameters/paging_page"
+        - $ref: "#/components/parameters/paging_per_page"
+      x-java-response:
+        type: java.util.stream.Stream
+        isContainer: true
+      security: [ ]
+      responses:
+        200:
+          description: A list of consumer feed information objects.
+          content:
+            application/json:
+              schema:
+                type: array
+                items:
+                  $ref: '#/components/schemas/ConsumerFeedDTO'
+        400:
+          description: Bad request due to invalid query parameters.
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/ExceptionMessage'
+              example:
+                displayMessage: Invalid input parameters
+                requestUuid: c4347004-8792-41fe-a4d8-fccaa0d3898a
+        403:
+          description: Insufficient permissions
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/ExceptionMessage'
+              example:
+                displayMessage: Insufficient permissions
+                requestUuid: c4347004-8792-41fe-a4d8-fccaa0d3898a
+        default:
+          $ref: '#/components/responses/default'
+
 components:
   responses:
     default:
@@ -9072,6 +9143,53 @@ components:
                 items:
                   $ref: '#/components/schemas/EnvironmentDTO'
 
+    ConsumerFeedDTO:
+      description: Represents a consumer feed DTO for compatibility with RHSM API
+      type: object
+      properties:
+        id:
+          type: string
+          deprecated: true
+        uuid:
+          type: string
+        name:
+          type: string
+        type:
+          $ref: '#/components/schemas/ConsumerTypeDTO'
+        ownerKey:
+          type: string
+        lastCheckin:
+          type: string
+          format: date-time
+        guestId:
+          type: string
+        hypervisorUuid:
+          type: string
+        hypervisorName:
+          type: string
+        serviceLevel:
+          type: string
+        syspurposeRole:
+          type: string
+        syspurposeUsage:
+          type: string
+        syspurposeAddons:
+          type: array
+          uniqueItems: true
+          items:
+            type: string
+        releaseVer:
+          $ref: '#/components/schemas/ReleaseVerDTO'
+        facts:
+          type: object
+          additionalProperties:
+            type: string
+        installedProducts:
+          type: array
+          uniqueItems: true
+          items:
+            $ref: '#/components/schemas/ConsumerInstalledProductDTO'
+
     ConsumerActivationKeyDTO:
       description: Represent activation keys used by consumer in registration
       properties:
diff --git a/src/main/java/org/candlepin/model/ConsumerFeed.java b/src/main/java/org/candlepin/model/ConsumerFeed.java
new file mode 100644
index 000000000..ab3ccbcc5
--- /dev/null
+++ b/src/main/java/org/candlepin/model/ConsumerFeed.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) 2009 - 2025 Red Hat, Inc.
+ *
+ * This software is licensed to you under the GNU General Public License,
+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or
+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
+ * along with this software; if not, see
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * Red Hat trademarks are not licensed under GPLv2. No permission is
+ * granted to use or replicate Red Hat trademarks that are incorporated
+ * in this software or its documentation.
+ */
+
+package org.candlepin.model;
+
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class ConsumerFeed {
+
+    private String id;
+    private String uuid;
+    private String name;
+    private String typeId;
+    private String ownerKey;
+    private String guestId;
+    private String hypervisorUuid;
+    private String hypervisorName;
+    private String serviceLevel;
+    private String syspurposeRole;
+    private String syspurposeUsage;
+    private Set<String> syspurposeAddons;
+    private String releaseVer;
+    private Map<String, String> facts;
+    private Date lastCheckin;
+    private List<ConsumerInstalledProduct> installedProducts;
+
+    public ConsumerFeed(String id, String uuid, String name, String typeId, String ownerKey, Date lastCheckin,
+        String serviceLevel, String role, String releaseVer) {
+        this.id = id;
+        this.uuid = uuid;
+        this.name = name;
+        this.typeId = typeId;
+        this.ownerKey = ownerKey;
+        this.lastCheckin = lastCheckin;
+        this.serviceLevel = serviceLevel;
+        this.syspurposeRole = role;
+        this.releaseVer = releaseVer;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public String getUuid() {
+        return uuid;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getTypeId() {
+        return typeId;
+    }
+
+    public String getOwnerKey() {
+        return ownerKey;
+    }
+
+    public String getGuestId() {
+        return guestId;
+    }
+
+    public String getHypervisorUuid() {
+        return hypervisorUuid;
+    }
+
+    public String getHypervisorName() {
+        return hypervisorName;
+    }
+
+    public String getServiceLevel() {
+        return serviceLevel;
+    }
+
+    public String getSyspurposeRole() {
+        return syspurposeRole;
+    }
+
+    public String getSyspurposeUsage() {
+        return syspurposeUsage;
+    }
+
+    public Set<String> getSyspurposeAddons() {
+        return syspurposeAddons;
+    }
+
+    public String getReleaseVer() {
+        return releaseVer;
+    }
+
+    public Map<String, String> getFacts() {
+        return facts;
+    }
+
+    public Date getLastCheckin() {
+        return lastCheckin;
+    }
+
+    public List<ConsumerInstalledProduct> getInstalledProducts() {
+        return installedProducts;
+    }
+
+    public ConsumerFeed setId(String id) {
+        this.id = id;
+        return this;
+    }
+
+    public ConsumerFeed setUuid(String uuid) {
+        this.uuid = uuid;
+        return this;
+    }
+
+    public ConsumerFeed setName(String name) {
+        this.name = name;
+        return this;
+    }
+
+    public ConsumerFeed setTypeId(String typeId) {
+        this.typeId = typeId;
+        return this;
+    }
+
+    public ConsumerFeed setOwnerKey(String ownerKey) {
+        this.ownerKey = ownerKey;
+        return this;
+    }
+
+    public ConsumerFeed setGuestId(String guestId) {
+        this.guestId = guestId;
+        return this;
+    }
+
+    public ConsumerFeed setHypervisorUuid(String hypervisorUuid) {
+        this.hypervisorUuid = hypervisorUuid;
+        return this;
+    }
+
+    public ConsumerFeed setHypervisorName(String hypervisorName) {
+        this.hypervisorName = hypervisorName;
+        return this;
+    }
+
+    public ConsumerFeed setServiceLevel(String serviceLevel) {
+        this.serviceLevel = serviceLevel;
+        return this;
+    }
+
+    public ConsumerFeed setSyspurposeRole(String syspurposeRole) {
+        this.syspurposeRole = syspurposeRole;
+        return this;
+    }
+
+    public ConsumerFeed setSyspurposeUsage(String syspurposeUsage) {
+        this.syspurposeUsage = syspurposeUsage;
+        return this;
+    }
+
+    public ConsumerFeed setSyspurposeAddons(Set<String> syspurposeAddons) {
+        this.syspurposeAddons = syspurposeAddons;
+        return this;
+    }
+
+    public ConsumerFeed setReleaseVer(String releaseVer) {
+        this.releaseVer = releaseVer;
+        return this;
+    }
+
+    public ConsumerFeed setFacts(Map<String, String> facts) {
+        this.facts = facts;
+        return this;
+    }
+
+    public ConsumerFeed setLastCheckin(Date lastCheckin) {
+        this.lastCheckin = lastCheckin;
+        return this;
+    }
+
+    public ConsumerFeed setInstalledProducts(List<ConsumerInstalledProduct> installedProducts) {
+        this.installedProducts = installedProducts;
+        return this;
+    }
+}
diff --git a/src/main/java/org/candlepin/model/HypervisorGuestMapping.java b/src/main/java/org/candlepin/model/HypervisorGuestMapping.java
new file mode 100644
index 000000000..e9a3faec6
--- /dev/null
+++ b/src/main/java/org/candlepin/model/HypervisorGuestMapping.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2009 - 2025 Red Hat, Inc.
+ *
+ * This software is licensed to you under the GNU General Public License,
+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or
+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
+ * along with this software; if not, see
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * Red Hat trademarks are not licensed under GPLv2. No permission is
+ * granted to use or replicate Red Hat trademarks that are incorporated
+ * in this software or its documentation.
+ */
+
+package org.candlepin.model;
+
+public record HypervisorGuestMapping(
+    String hypervisorId,
+    String hypervisorName,
+    String hypervisorUuid,
+    String guestId
+) {}
diff --git a/src/main/java/org/candlepin/model/InstalledProduct.java b/src/main/java/org/candlepin/model/InstalledProduct.java
new file mode 100644
index 000000000..813a7ab60
--- /dev/null
+++ b/src/main/java/org/candlepin/model/InstalledProduct.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2009 - 2025 Red Hat, Inc.
+ *
+ * This software is licensed to you under the GNU General Public License,
+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or
+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
+ * along with this software; if not, see
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * Red Hat trademarks are not licensed under GPLv2. No permission is
+ * granted to use or replicate Red Hat trademarks that are incorporated
+ * in this software or its documentation.
+ */
+
+package org.candlepin.model;
+
+public record InstalledProduct(String productId, String productName, String productVersion) {
+}
+
diff --git a/src/main/java/org/candlepin/model/RhsmApiCompatCurator.java b/src/main/java/org/candlepin/model/RhsmApiCompatCurator.java
new file mode 100644
index 000000000..d76ee6a55
--- /dev/null
+++ b/src/main/java/org/candlepin/model/RhsmApiCompatCurator.java
@@ -0,0 +1,416 @@
+/*
+ * Copyright (c) 2009 - 2025 Red Hat, Inc.
+ *
+ * This software is licensed to you under the GNU General Public License,
+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or
+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
+ * along with this software; if not, see
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * Red Hat trademarks are not licensed under GPLv2. No permission is
+ * granted to use or replicate Red Hat trademarks that are incorporated
+ * in this software or its documentation.
+ */
+
+package org.candlepin.model;
+
+import org.candlepin.config.Configuration;
+import org.candlepin.util.ConsumerFeedFactExtractor;
+import org.candlepin.util.Util;
+
+import com.google.inject.Inject;
+import com.google.inject.Provider;
+
+import org.hibernate.Session;
+import org.hibernate.dialect.Dialect;
+import org.hibernate.engine.spi.SessionFactoryImplementor;
+
+import java.time.OffsetDateTime;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+import javax.inject.Singleton;
+import javax.persistence.EntityManager;
+import javax.persistence.Query;
+import javax.persistence.TypedQuery;
+
+/**
+ * Curator for retrieving persisted data for operations needed by RHSM API.
+ */
+@Singleton
+public class RhsmApiCompatCurator {
+
+    private final EntityManager entityManager;
+
+    @Inject
+    public RhsmApiCompatCurator(Provider<EntityManager> entityManager, Configuration config) {
+        Provider<EntityManager> provider = Objects.requireNonNull(entityManager);
+
+        this.entityManager = provider.get();
+    }
+
+    /**
+     * Retrieves a list of {@link ConsumerFeed} objects for a given owner. The resulting list is paginated
+     * and ordered deterministically by ID and last check-in. For each consumer, relevant facts and
+     * installed products are extracted, and if the consumer represents a virtual machine (as indicated by
+     * the "virt.uuid" fact), an associated hypervisor is looked up by matching all possible UUID
+     * representations.
+     *
+     * @param owner         the {@link Owner} whose consumers are to be fetched; must not be null
+     * @param afterId       (optional) only consumers with an ID lexicographically greater than this value
+     *                      will be included
+     * @param afterUuid     (optional) only consumers with a UUID lexicographically greater than this value
+     *                      will be included
+     * @param afterCheckin  (optional) only consumers with a last check-in timestamp after this value will
+     *                      be included
+     * @param page          the page number to retrieve (1-based)
+     * @param perPage       the number of consumers to return per page
+     * @return a list of {@link ConsumerFeed} objects matching the specified filters, with facts, installed
+     *         products, add-ons, and hypervisor association (if applicable) fully populated
+     */
+    public List<ConsumerFeed> getConsumerFeed(Owner owner, String afterId, String afterUuid,
+        OffsetDateTime afterCheckin, int page, int perPage) {
+
+        List<ConsumerFeed> consumersFiltered = getConsumersFiltered(owner.getOwnerKey(), afterId, afterUuid,
+            afterCheckin, page, perPage);
+        Map<String, HypervisorGuestMapping> hypervisorGuestMappings =
+            getHypervisorGuestMappingsByConsumer(owner.getOwnerId());
+        Map<String, Set<String>> addOnsByConsumer =
+            getAddOnsByConsumer(owner.getOwnerId(), afterId, afterUuid, afterCheckin, page, perPage);
+        Map<String, Map<String, String>> factsByConsumer =
+            getFactsByConsumer(owner.getOwnerId(), afterId, afterUuid, afterCheckin, page, perPage);
+        Map<String, List<ConsumerInstalledProduct>> installedProductsByConsumer =
+            getInstalledProductsByConsumer(owner.getOwnerId(), afterId, afterUuid, afterCheckin, page,
+                perPage);
+
+        for (ConsumerFeed consumerFeed : consumersFiltered) {
+            Map<String, String> facts = factsByConsumer.get(consumerFeed.getId());
+
+            // We must match the consumer's "virt.uuid" fact against all possible endianness variants,
+            // because guest IDs can be stored in partially reversed byte order in the database.
+            // By generating all possible UUID representations, we can correctly associate the consumer
+            // with its hypervisor if a mapping exists.
+            if (facts != null) {
+                String virtUuid = facts.get("virt.uuid");
+                if (virtUuid != null && !virtUuid.isEmpty()) {
+                    List<String> possibleUuids = Util.getPossibleUuids(virtUuid);
+                    for (String possible : possibleUuids) {
+                        HypervisorGuestMapping mapping = hypervisorGuestMappings.get(possible.toLowerCase());
+                        if (mapping != null) {
+                            consumerFeed.setHypervisorUuid(mapping.hypervisorUuid())
+                                .setHypervisorName(mapping.hypervisorName())
+                                .setGuestId(mapping.guestId());
+                            break;
+                        }
+                    }
+                }
+            }
+
+            consumerFeed
+                .setFacts(ConsumerFeedFactExtractor.extractRelevantFacts(facts))
+                .setInstalledProducts(installedProductsByConsumer.get(consumerFeed.getId()))
+                .setSyspurposeAddons(addOnsByConsumer.get(consumerFeed.getId()));
+        }
+
+        return consumersFiltered;
+    }
+
+    /**
+     * Retrieves list of {@link ConsumerFeed} objects for a given owner,
+     * filtered optionally by consumer ID, UUID, and last check-in timestamp.
+     * <p>
+     * This method constructs a dynamic HQL query to fetch consumers matching the provided filters,
+     * ordered deterministically by ID and last check-in timestamp (ascending). The query is paginated
+     * using the specified page and perPage parameters.
+     * <p>
+     * Only non-null filter parameters are applied. If no filters are provided, all consumers for the given
+     * owner are returned.
+     *
+     * @param ownerKey     the key of the owner whose consumers are to be fetched; must not be null or empty
+     * @param afterId      (optional) only consumers with an ID lexicographically greater than this value
+     *                     will be included
+     * @param afterUuid    (optional) only consumers with a UUID lexicographically greater than this value
+     *                     will be included
+     * @param afterCheckin (optional) only consumers with a last check-in timestamp after this value will
+     *                     be included
+     * @param page         the page number to retrieve
+     * @param perPage      the number of consumers to return per page
+     * @return a list of {@link ConsumerFeed} matching the given filters and paging criteria
+     */
+    private List<ConsumerFeed> getConsumersFiltered(String ownerKey, String afterId, String afterUuid,
+        OffsetDateTime afterCheckin, int page, int perPage) {
+
+        StringBuilder hql = new StringBuilder(
+            "SELECT new org.candlepin.model.ConsumerFeed(" +
+            "c.id, c.uuid, c.name, c.typeId, c.owner.key, c.lastCheckin, " +
+            "c.serviceLevel, c.role, c.releaseVer)" +
+            "FROM Consumer c WHERE c.owner.key = :owner");
+
+        if (afterId != null) {
+            hql.append(" AND c.id > :afterId");
+        }
+        if (afterUuid != null) {
+            hql.append(" AND c.uuid > :afterUuid");
+        }
+        if (afterCheckin != null) {
+            hql.append(" AND c.lastCheckin > :afterCheckin");
+        }
+
+        hql.append(" ORDER BY c.id ASC, c.lastCheckin ASC");
+
+        TypedQuery<ConsumerFeed> query = entityManager.createQuery(hql.toString(), ConsumerFeed.class)
+            .setParameter("owner", ownerKey);
+
+        if (afterId != null) {
+            query.setParameter("afterId", afterId);
+        }
+        if (afterUuid != null) {
+            query.setParameter("afterUuid", afterUuid);
+        }
+        if (afterCheckin != null) {
+            query.setParameter("afterCheckin", Date.from(afterCheckin.toInstant()));
+        }
+
+        int offset = (page - 1) * perPage;
+        query.setFirstResult(offset);
+        query.setMaxResults(perPage);
+
+        return query.getResultList();
+    }
+
+    /**
+     * Retrieves a mapping from guest UUID variants (including all endianness forms) to
+     * {@link HypervisorGuestMapping} for all hypervisor-guest relationships within a given owner. Used for
+     * efficient resolution of hypervisor information for consumers based on "virt.uuid" facts.
+     * <p>
+     * The mapping includes all recognized UUID encodings, as required by Candlepin's guest mapping rules.
+     * If multiple mappings exist for the same guest, only the most recent (by update timestamp, creation
+     * timestamp, and entry ID) is included, using database-specific logic for ranking or aggregation.
+     *
+     * @param ownerId the ID of the owner whose hypervisor-guest mappings are to be retrieved;
+     *                must not be null
+     * @return a map where each key is a lower-cased guest UUID variant and each value is the corresponding
+     *         {@link HypervisorGuestMapping}
+     */
+    private Map<String, HypervisorGuestMapping> getHypervisorGuestMappingsByConsumer(String ownerId) {
+        String sql;
+        String databaseDialect = getDatabaseDialect();
+
+        if (databaseDialect.contains("mysql") || databaseDialect.contains("maria") ||
+            databaseDialect.contains("postgres")) {
+            sql =
+                "SELECT hypervisor.id, hypervisor.uuid, hypervisor.name, guest.guest_id " +
+                "FROM ( " +
+                "  SELECT hypervisor.id AS hypervisor_id, hypervisor.uuid AS hypervisor_uuid, " +
+                "         guest.guest_id, " +
+                "         DENSE_RANK() OVER (PARTITION BY guest.guest_id " +
+                "           ORDER BY guest.updated DESC, guest.created DESC, guest.id ASC) AS rank " +
+                "    FROM cp_consumer hypervisor " +
+                "    JOIN cp_consumer_guests guest ON guest.consumer_id = hypervisor.id " +
+                "   WHERE hypervisor.owner_id = :owner_id " +
+                ") hgmap " +
+                "WHERE rank = 1";
+        }
+        else {
+            sql =
+                "SELECT hypervisor.id, hypervisor.uuid, hypervisor.name, guest.guest_id " +
+                "FROM cp_consumer hypervisor " +
+                "JOIN cp_consumer_guests guest ON guest.consumer_id = hypervisor.id " +
+                "JOIN ( " +
+                "    SELECT guest_id, MAX(updated) AS last_updated " +
+                "    FROM cp_consumer_guests " +
+                "    GROUP BY guest_id " +
+                ") glu " +
+                "ON glu.guest_id = guest.guest_id AND glu.last_updated = guest.updated " +
+                "WHERE hypervisor.owner_id = :owner_id";
+        }
+
+        List<Object[]> rows = entityManager.createNativeQuery(sql)
+            .setParameter("owner_id", ownerId)
+            .getResultList();
+
+        Map<String, HypervisorGuestMapping> result = new HashMap<>();
+        for (Object[] row : rows) {
+            String hypervisorId = (String) row[0];
+            String hypervisorUuid = (String) row[1];
+            String hypervisorName = (String) row[2];
+            String guestId = (String) row[3];
+            HypervisorGuestMapping mapping = new HypervisorGuestMapping(
+                hypervisorId, hypervisorUuid, hypervisorName, guestId);
+
+            // Since we know there will be at most 1000 consumer records, we can preload all mappings.
+            // This avoids looping through all consumer feeds for each lookup and improves performance.
+            List<String> guestIdVariants = Util.getPossibleUuids(guestId);
+            for (String variant : guestIdVariants) {
+                result.put(variant.toLowerCase(), mapping);
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Retrieves a mapping from consumer ID to a list of {@link ConsumerInstalledProduct} for all
+     * installed products belonging to consumers matching the specified owner and filter criteria.
+     *
+     * @param ownerId      the ID of the owner whose consumers' products are to be fetched; must not be null
+     * @param afterId      (optional) only consumers with an ID lexicographically greater than this value
+     *                     will be included
+     * @param afterUuid    (optional) only consumers with a UUID lexicographically greater than this value
+     *                     will be included
+     * @param afterCheckin (optional) only consumers with a last check-in timestamp after this value will
+     *                     be included
+     * @param page         the page number to retrieve
+     * @param perPage      the number of consumers to return per page
+     * @return a map where each key is a consumer ID and each value is a list of installed products
+     * for that consumer
+     */
+    private Map<String, List<ConsumerInstalledProduct>> getInstalledProductsByConsumer(String ownerId,
+        String afterId, String afterUuid, OffsetDateTime afterCheckin, int page, int perPage) {
+        String cte = buildConsumersCte(afterId, afterUuid, afterCheckin);
+        String sql =
+            "SELECT ip.consumer_id, ip.product_id, ip.product_name, ip.product_version " +
+            "FROM cp_installed_products ip " +
+            "JOIN (" + cte + ") cids ON cids.id = ip.consumer_id";
+
+        Query q = entityManager.createNativeQuery(sql);
+        setConsumerParams(q, ownerId, afterId, afterUuid, afterCheckin, page, perPage);
+
+        List<Object[]> rows = q.getResultList();
+        Map<String, List<ConsumerInstalledProduct>> result = new HashMap<>();
+        for (Object[] row : rows) {
+            String consumerId = String.valueOf(row[0]);
+            String productId = String.valueOf(row[1]);
+            String productName = String.valueOf(row[2]);
+            String productVersion = String.valueOf(row[3]);
+            result.computeIfAbsent(consumerId, k -> new ArrayList<>())
+                .add(new ConsumerInstalledProduct()
+                    .setProductId(productId)
+                    .setProductName(productName)
+                    .setVersion(productVersion));
+        }
+        return result;
+    }
+
+    /**
+     * Retrieves a mapping from consumer ID to a set of add-on names for all consumers matching the specified
+     * owner and filter criteria.
+     *
+     * @param ownerId      the ID of the owner whose consumers' add-ons are to be fetched; must not be null
+     * @param afterId      (optional) only consumers with an ID lexicographically greater than this value
+     *                     will be included
+     * @param afterUuid    (optional) only consumers with a UUID lexicographically greater than this value
+     *                     will be included
+     * @param afterCheckin (optional) only consumers with a last check-in timestamp after this value will
+     *                     be included
+     * @param page         the page number to retrieve
+     * @param perPage      the number of consumers to return per page
+     * @return a map where each key is a consumer ID and each value is a set of add-on names for that consumer
+     */
+    private Map<String, Set<String>> getAddOnsByConsumer(String ownerId, String afterId, String afterUuid,
+        OffsetDateTime afterCheckin, int page, int perPage) {
+        String cte = buildConsumersCte(afterId, afterUuid, afterCheckin);
+        String sql =
+            "SELECT spao.consumer_id, spao.add_on " +
+            "FROM cp_sp_add_on spao " +
+            "JOIN (" + cte + ") cids ON cids.id = spao.consumer_id";
+
+        Query q = entityManager.createNativeQuery(sql);
+        setConsumerParams(q, ownerId, afterId, afterUuid, afterCheckin, page, perPage);
+
+        List<Object[]> rows = q.getResultList();
+        Map<String, Set<String>> result = new HashMap<>();
+        for (Object[] row : rows) {
+            String consumerId = String.valueOf(row[0]);
+            String addOn = String.valueOf(row[1]);
+            result.computeIfAbsent(consumerId, k -> new HashSet<>()).add(addOn);
+        }
+        return result;
+    }
+
+    /**
+     * Retrieves a mapping from consumer ID to a map of fact keys and values for all consumers matching
+     * the specified owner and filter criteria.
+     *
+     * @param ownerId      the ID of the owner whose consumers' facts are to be fetched; must not be null
+     * @param afterId      (optional) only consumers with an ID lexicographically greater than this value
+     *                     will be included
+     * @param afterUuid    (optional) only consumers with a UUID lexicographically greater than this value
+     *                     will be included
+     * @param afterCheckin (optional) only consumers with a last check-in timestamp after this value will
+     *                     be included
+     * @param page         the page number to retrieve
+     * @param perPage      the number of consumers to return per page
+     * @return a map where each key is a consumer ID and each value is a map of fact key-value pairs
+     * for that consumer
+     */
+    private Map<String, Map<String, String>> getFactsByConsumer(String ownerId, String afterId,
+        String afterUuid, OffsetDateTime afterCheckin, int page, int perPage) {
+        String cte = buildConsumersCte(afterId, afterUuid, afterCheckin);
+        String sql =
+            "SELECT fact.cp_consumer_id AS consumer_id, fact.mapkey, fact.element " +
+            "FROM cp_consumer_facts fact " +
+            "JOIN (" + cte + ") cids ON cids.id = fact.cp_consumer_id";
+
+        Query q = entityManager.createNativeQuery(sql);
+        setConsumerParams(q, ownerId, afterId, afterUuid, afterCheckin, page, perPage);
+
+        List<Object[]> rows = q.getResultList();
+        Map<String, Map<String, String>> result = new HashMap<>();
+        for (Object[] row : rows) {
+            String consumerId = String.valueOf(row[0]);
+            String mapKey = String.valueOf(row[1]);
+            String value = String.valueOf(row[2]);
+            result.computeIfAbsent(consumerId, k -> new HashMap<>()).put(mapKey, value);
+        }
+        return result;
+    }
+
+    private String buildConsumersCte(String afterId, String afterUuid, OffsetDateTime afterCheckin) {
+        StringBuilder sb = new StringBuilder("SELECT id FROM cp_consumer WHERE owner_id = :owner_id");
+        if (afterId != null) {
+            sb.append(" AND id > :after_id");
+        }
+        if (afterUuid != null) {
+            sb.append(" AND uuid > :after_uuid");
+        }
+        if (afterCheckin != null) {
+            sb.append(" AND lastcheckin > :after_checkin");
+        }
+        sb.append(" ORDER BY id ASC, lastcheckin ASC OFFSET :offset LIMIT :limit");
+        return sb.toString();
+    }
+
+    private void setConsumerParams(Query q, String ownerId, String afterId, String afterUuid,
+        OffsetDateTime afterCheckin, int page, int perPage) {
+        q.setParameter("owner_id", ownerId);
+        if (afterId != null) {
+            q.setParameter("after_id", afterId);
+        }
+        if (afterUuid != null) {
+            q.setParameter("after_uuid", afterUuid);
+        }
+        if (afterCheckin != null) {
+            q.setParameter("after_checkin", afterCheckin);
+        }
+
+        int offset = (page - 1) * perPage;
+        q.setParameter("offset", offset);
+        q.setParameter("limit", perPage);
+    }
+
+
+    private String getDatabaseDialect() {
+        Session session = entityManager.unwrap(Session.class);
+        SessionFactoryImplementor sfi = (SessionFactoryImplementor) session.getSessionFactory();
+        Dialect dialect = sfi.getJdbcServices().getDialect();
+        return dialect.toString().toLowerCase();
+    }
+
+}
diff --git a/src/main/java/org/candlepin/resource/RhsmApiCompatResource.java b/src/main/java/org/candlepin/resource/RhsmApiCompatResource.java
new file mode 100644
index 000000000..b41e099a4
--- /dev/null
+++ b/src/main/java/org/candlepin/resource/RhsmApiCompatResource.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2009 - 2025 Red Hat, Inc.
+ *
+ * This software is licensed to you under the GNU General Public License,
+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or
+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
+ * along with this software; if not, see
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * Red Hat trademarks are not licensed under GPLv2. No permission is
+ * granted to use or replicate Red Hat trademarks that are incorporated
+ * in this software or its documentation.
+ */
+
+package org.candlepin.resource;
+
+import org.candlepin.dto.api.server.v1.ConsumerFeedDTO;
+import org.candlepin.exceptions.BadRequestException;
+import org.candlepin.model.Owner;
+import org.candlepin.model.OwnerCurator;
+import org.candlepin.model.RhsmApiCompatCurator;
+import org.candlepin.paging.Page;
+import org.candlepin.paging.PageRequest;
+import org.candlepin.resource.server.v1.RhsmapiApi;
+
+import com.google.inject.Inject;
+import com.google.inject.persist.Transactional;
+
+import org.jboss.resteasy.core.ResteasyContext;
+import org.xnap.commons.i18n.I18n;
+
+import java.time.OffsetDateTime;
+import java.util.Objects;
+import java.util.stream.Stream;
+
+/**
+ * Entry point for endpoints that are dedicated for RHSM API for compatibility reasons.
+ */
+public class RhsmApiCompatResource implements RhsmapiApi {
+
+    private I18n i18n;
+    OwnerCurator ownerCurator;
+    RhsmApiCompatCurator rhsmApiCurator;
+
+    @Inject
+    public RhsmApiCompatResource(I18n i18n, OwnerCurator ownerCurator, RhsmApiCompatCurator rhsmApiCurator) {
+        this.i18n = i18n;
+        this.ownerCurator = ownerCurator;
+        this.rhsmApiCurator = Objects.requireNonNull(rhsmApiCurator);
+    }
+
+    @Override
+    @Transactional
+    public Stream<ConsumerFeedDTO> getConsumerFeed(String orgKey, String afterId, String afterUuid,
+        OffsetDateTime afterCheckin, Integer page, Integer perPage) {
+
+        if (orgKey == null || orgKey.trim().isEmpty()) {
+            // TODO: We need to agree what we want to return 404 or empty list depends on what we use in
+            // rest of the RHSM API replacement
+            return Stream.empty();
+        }
+
+        Owner owner = this.ownerCurator.getByKey(orgKey);
+        if (owner == null) {
+            return Stream.empty();
+        }
+
+        //Paging bit
+        int offset = 1;
+        int limit = 1000;
+        PageRequest pageRequest = ResteasyContext.getContextData(PageRequest.class);
+        if (pageRequest != null) {
+            Page<Stream<ConsumerFeedDTO>> pageResponse = new Page<>();
+            pageResponse.setPageRequest(pageRequest);
+
+            if (pageRequest.isPaging()) {
+                offset = pageRequest.getPage();
+                limit = pageRequest.getPerPage();
+                if (offset < 1) {
+                    throw new BadRequestException(i18n.tr("Parameter page must be positive integer"));
+                }
+                if (limit < 1 || limit > 1000) {
+                    throw new BadRequestException(i18n.tr("Parameter per_page must be in range 1-1000"));
+                }
+            }
+
+            // Store the page for the LinkHeaderResponseFilter
+            ResteasyContext.pushContext(Page.class, pageResponse);
+        }
+
+        // TODO: rename orgKey to match codebase to owner
+        rhsmApiCurator.getConsumerFeed(owner, afterId, afterUuid, afterCheckin, offset, limit);
+
+        return Stream.empty();
+    }
+}
diff --git a/src/main/java/org/candlepin/util/ConsumerFeedFactExtractor.java b/src/main/java/org/candlepin/util/ConsumerFeedFactExtractor.java
new file mode 100644
index 000000000..1bc9ee4ec
--- /dev/null
+++ b/src/main/java/org/candlepin/util/ConsumerFeedFactExtractor.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2009 - 2025 Red Hat, Inc.
+ *
+ * This software is licensed to you under the GNU General Public License,
+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or
+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
+ * along with this software; if not, see
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * Red Hat trademarks are not licensed under GPLv2. No permission is
+ * granted to use or replicate Red Hat trademarks that are incorporated
+ * in this software or its documentation.
+ */
+
+package org.candlepin.util;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+public class ConsumerFeedFactExtractor {
+
+    private ConsumerFeedFactExtractor() {
+        // Intentionally left empty
+    }
+
+    // List of allowed fact keys (exact matches)
+    private static final Set<String> ALLOWED_FACTS = Set.of(
+        "cpu.cpu(s)",
+        "cpu.cpu_socket(s)",
+        "cpu.thread(s)_per_core",
+        "distribution.version",
+        "network.fqdn",
+        "bios.version",
+        "dmi.bios.vendor",
+        "network.hostname",
+        "dmi.system.manufacturer",
+        "dmi.system.product_name",
+        "insights_id",
+        "conversions.activity",
+        "dmi.system.uuid",
+        "uname.nodename",
+        "distribution.name",
+        "memory.memtotal",
+        "cpu.core(s)_per_socket",
+        "uname.machine",
+        "network.ipv6_address",
+        "dmi.chassis.asset_tag",
+        "dmi.bios.version",
+        "virt.is_guest",
+        "band.storage.usage",
+        "network.ipv4_address"
+    );
+
+    // List of allowed patterns (regular expressions)
+    private static final List<Pattern> ALLOWED_PATTERNS = List.of(
+        Pattern.compile("^net\\.interface\\..+?\\.mac_address$"),
+        Pattern.compile("^net\\.interface\\..+?\\.ipv4_address$"),
+        Pattern.compile("^net\\.interface\\..+?\\.ipv6_address.global$"),
+        Pattern.compile("^net\\.interface\\..+?\\.ipv6_address.link$"),
+        Pattern.compile("^net\\.interface\\..+?\\.ipv4_address_list$"),
+        Pattern.compile("^net\\.interface\\..+?\\.ipv6_address.global_list$"),
+        Pattern.compile("^net\\.interface\\..+?\\.pv6_address.link_list$"),
+        Pattern.compile("^ocm\\."),
+        Pattern.compile("^openshift\\."),
+        Pattern.compile("^azure_"),
+        Pattern.compile("^aws_"),
+        Pattern.compile("^gcp_")
+    );
+
+    /**
+     * Extracts only the relevant facts from the given map, based on allowed keys and patterns.
+     *
+     * @param allFacts a map of all available facts (key -> value)
+     * @return a filtered map containing only the allowed facts
+     */
+    public static Map<String, String> extractRelevantFacts(Map<String, String> allFacts) {
+        Map<String, String> result = new HashMap<>();
+        if (allFacts == null) {
+            return result;
+        }
+        for (Map.Entry<String, String> entry : allFacts.entrySet()) {
+            String key = entry.getKey();
+
+            // Check for an exact allowed key
+            if (ALLOWED_FACTS.contains(key)) {
+                result.put(key, entry.getValue());
+                continue;
+            }
+
+            // Check all allowed regular expression patterns
+            for (Pattern pattern : ALLOWED_PATTERNS) {
+                if (pattern.matcher(key).find()) {
+                    result.put(key, entry.getValue());
+                    break;
+                }
+            }
+        }
+        return result;
+    }
+}
diff --git a/src/test/java/org/candlepin/model/RhsmApiCompatCuratorTest.java b/src/test/java/org/candlepin/model/RhsmApiCompatCuratorTest.java
new file mode 100644
index 000000000..5c798c172
--- /dev/null
+++ b/src/test/java/org/candlepin/model/RhsmApiCompatCuratorTest.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright (c) 2009 - 2025 Red Hat, Inc.
+ *
+ * This software is licensed to you under the GNU General Public License,
+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or
+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
+ * along with this software; if not, see
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * Red Hat trademarks are not licensed under GPLv2. No permission is
+ * granted to use or replicate Red Hat trademarks that are incorporated
+ * in this software or its documentation.
+ */
+
+package org.candlepin.model;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.candlepin.test.DatabaseTestFixture;
+import org.candlepin.test.TestUtil;
+
+import org.junit.jupiter.api.Test;
+
+import java.time.OffsetDateTime;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class RhsmApiCompatCuratorTest extends DatabaseTestFixture {
+
+    @Test
+    public void testGetConsumerFeedFilterByOwner() {
+        Owner ownerA = createOwner("A");
+        Owner ownerB = createOwner("B");
+        Consumer consumerA1 = createConsumer(ownerA);
+        Consumer consumerA2 = createConsumer(ownerA);
+        Consumer consumerB1 = createConsumer(ownerB);
+
+        List<ConsumerFeed> result = rhsmApiCompatCurator.getConsumerFeed(ownerA, null, null, null, 1,
+            10);
+
+        assertThat(result).extracting(ConsumerFeed::getId)
+            .containsExactly(consumerA1.getId(), consumerA2.getId());
+    }
+
+    @Test
+    public void testGetConsumerFeedFilterByAfterId() {
+        Owner owner = createOwner("C");
+        Consumer c1 = createConsumer(owner);
+        Consumer c2 = createConsumer(owner);
+        Consumer c3 = createConsumer(owner);
+
+        // Should only return consumers with id > id20
+        List<ConsumerFeed> result = rhsmApiCompatCurator.getConsumerFeed(owner, c2.getId(), null,
+            null, 1, 10);
+
+        assertThat(result).extracting(ConsumerFeed::getId).containsExactly(c3.getId());
+    }
+
+    @Test
+    public void testGetConsumerFeedFilterByAfterUuid() {
+        Owner owner = createOwner("D");
+        Consumer c1 = createConsumer(owner, "uuid1", null, null, null, null);
+        Consumer c2 = createConsumer(owner, "uuid2", null, null, null, null);
+        Consumer c3 = createConsumer(owner, "uuid3", null, null, null, null);
+
+        // Should only return consumers with uuid1 > uuid2 (lexicographically)
+        List<ConsumerFeed> result = rhsmApiCompatCurator.getConsumerFeed(owner, null, "uuid2", null,
+            1, 10);
+
+        assertThat(result).extracting(ConsumerFeed::getUuid).containsExactly("uuid3");
+    }
+
+    @Test
+    public void testGetConsumerFeedFilterByAfterCheckin() {
+        Owner owner = createOwner("E");
+        OffsetDateTime ts1 = OffsetDateTime.now().minusDays(3);
+        OffsetDateTime ts2 = OffsetDateTime.now().minusDays(2);
+        OffsetDateTime ts3 = OffsetDateTime.now().minusDays(1);
+        Consumer c1 = createConsumer(owner, "uuidX", Date.from(ts1.toInstant()), null, null, null);
+        Consumer c2 = createConsumer(owner, "uuidY", Date.from(ts2.toInstant()), null, null, null);
+        Consumer c3 = createConsumer(owner, "uuidZ", Date.from(ts3.toInstant()), null, null, null);
+
+        // Only return those after ts2 (should get c3 only)
+        List<ConsumerFeed> result = rhsmApiCompatCurator.getConsumerFeed(owner, null, null, ts2, 1,
+            10);
+
+        assertThat(result).extracting(ConsumerFeed::getId).containsExactly(c3.getId());
+    }
+
+    @Test
+    public void testGetConsumerFeedFilterByAfterIdAndCheckin() {
+        Owner owner = createOwner("G");
+        OffsetDateTime ts1 = OffsetDateTime.now().minusDays(3);
+        OffsetDateTime ts2 = OffsetDateTime.now().minusDays(2);
+        OffsetDateTime ts3 = OffsetDateTime.now().minusDays(1);
+
+        Consumer c1 = createConsumer(owner, "uuidX", Date.from(ts1.toInstant()), null, null, null);
+        Consumer c2 = createConsumer(owner, "uuidY", Date.from(ts2.toInstant()), null, null, null);
+        Consumer c3 = createConsumer(owner, "uuidZ", Date.from(ts3.toInstant()), null, null, null);
+
+        // id > c1.getId() AND checkin > ts1 → c2 a c3
+        List<ConsumerFeed> result = rhsmApiCompatCurator.getConsumerFeed(owner, c1.getId(), null,
+            ts1, 1, 10);
+
+        assertThat(result).extracting(ConsumerFeed::getId).containsExactlyInAnyOrder(c2.getId(), c3.getId());
+    }
+
+    @Test
+    public void testGetConsumerFeedFilterByAfterIdAndUuid() {
+        Owner owner = createOwner("H");
+        Consumer c1 = createConsumer(owner, "uuid1", null, null, null, null);
+        Consumer c2 = createConsumer(owner, "uuid2", null, null, null, null);
+        Consumer c3 = createConsumer(owner, "uuid3", null, null, null, null);
+
+        // id > c1.getId() AND uuid > "uuid1" → c2, c3
+        List<ConsumerFeed> result = rhsmApiCompatCurator.getConsumerFeed(owner, c1.getId(), "uuid1",
+            null, 1, 10);
+
+        assertThat(result).extracting(ConsumerFeed::getUuid).containsExactlyInAnyOrder("uuid2", "uuid3");
+    }
+
+    @Test
+    public void testGetConsumerFeedFilterByAfterUuidAndCheckin() {
+        Owner owner = createOwner("I");
+        OffsetDateTime ts1 = OffsetDateTime.now().minusDays(3);
+        OffsetDateTime ts2 = OffsetDateTime.now().minusDays(2);
+        OffsetDateTime ts3 = OffsetDateTime.now().minusDays(1);
+
+        Consumer c1 = createConsumer(owner, "uuidA", Date.from(ts1.toInstant()), null, null, null);
+        Consumer c2 = createConsumer(owner, "uuidB", Date.from(ts2.toInstant()), null, null, null);
+        Consumer c3 = createConsumer(owner, "uuidC", Date.from(ts3.toInstant()), null, null, null);
+
+        // uuid > "uuidA" AND checkin > ts1 → c2, c3
+        List<ConsumerFeed> result = rhsmApiCompatCurator.getConsumerFeed(owner, null, "uuidA", ts1,
+            1, 10);
+
+        assertThat(result).extracting(ConsumerFeed::getUuid).containsExactlyInAnyOrder("uuidB", "uuidC");
+    }
+
+    @Test
+    public void testGetConsumerFeedFilterByAll() {
+        Owner owner = createOwner("F");
+        OffsetDateTime ts1 = OffsetDateTime.now().minusDays(5);
+        OffsetDateTime ts2 = OffsetDateTime.now().minusDays(3);
+        OffsetDateTime ts3 = OffsetDateTime.now().minusDays(1);
+        Consumer c1 = createConsumer(owner, "uuidA", Date.from(ts1.toInstant()), null, null, null);
+        Consumer c2 = createConsumer(owner, "uuidB", Date.from(ts2.toInstant()), null, null, null);
+        Consumer c3 = createConsumer(owner, "uuidC", Date.from(ts3.toInstant()), null, null, null);
+
+        List<ConsumerFeed> result = rhsmApiCompatCurator.getConsumerFeed(owner, c1.getId(), "uuidA",
+            ts1, 1, 10);
+
+        assertThat(result).extracting(ConsumerFeed::getId).containsExactlyInAnyOrder(c2.getId(), c3.getId());
+    }
+
+    @Test
+    public void testGetConsumerFeedPagingFirstAndSecondPage() {
+        Owner owner = createOwner("K");
+        Consumer c1 = createConsumer(owner, "uuid1", null, null, null, null);
+        Consumer c2 = createConsumer(owner, "uuid2", null, null, null, null);
+        Consumer c3 = createConsumer(owner, "uuid3", null, null, null, null);
+
+        List<ConsumerFeed> page1 = rhsmApiCompatCurator
+            .getConsumerFeed(owner, null, null, null, 1, 2);
+
+        assertThat(page1)
+            .hasSize(2);
+        assertThat(page1)
+            .extracting(ConsumerFeed::getUuid)
+            .containsExactly("uuid1", "uuid2");
+
+        List<ConsumerFeed> page2 = rhsmApiCompatCurator
+            .getConsumerFeed(owner, null, null, null, 2, 2);
+
+        assertThat(page2)
+            .hasSize(1);
+        assertThat(page2.get(0))
+            .extracting(ConsumerFeed::getUuid)
+            .isEqualTo("uuid3");
+    }
+
+    @Test
+    public void testGetFactsByConsumerReturnsOnlyRelevantFacts() {
+        Owner owner = createOwner("FactTest");
+        Map<String, String> facts = new HashMap<>();
+        facts.put("cpu.cpu_socket(s)", "2");             // allowed
+        facts.put("network.fqdn", "host.redhat.com");    // allowed
+        facts.put("random.fact", "xxx");                 // not allowed
+        Consumer consumer = createConsumer(owner, null, null, facts, null, null);
+
+        List<ConsumerFeed> consumerFeeds =
+            rhsmApiCompatCurator.getConsumerFeed(owner, null, null, null, 1, 100);
+
+        assertThat(consumerFeeds.get(0))
+            .extracting(ConsumerFeed::getFacts)
+            .satisfies(x -> {
+                assertThat(x).containsEntry("cpu.cpu_socket(s)", "2");
+                assertThat(x).containsEntry("network.fqdn", "host.redhat.com");
+                assertThat(x).doesNotContainKey("random.fact");
+            });
+    }
+
+    @Test
+    public void testGetAddOnsByConsumerReturnsAllAddOns() {
+        Owner owner = createOwner("AddOnTest");
+        HashSet<String> addOns = new HashSet<>();
+        addOns.add("addon1");
+        addOns.add("addon2");
+        Consumer consumer = createConsumer(owner, null, null, null, addOns, null);
+
+        List<ConsumerFeed> consumerFeed = rhsmApiCompatCurator.getConsumerFeed(owner, null, null, null, 1,
+            100);
+
+        assertThat(consumerFeed.get(0))
+            .extracting(ConsumerFeed::getSyspurposeAddons)
+            .satisfies(x -> {
+                assertThat(x).containsExactlyInAnyOrder("addon1", "addon2");
+            });
+    }
+
+    @Test
+    public void testGetConsumerFeedReturnsInstalledProducts() {
+        Owner owner = createOwner("ProductTest");
+        ConsumerInstalledProduct installedProd1 = createConsumerInstalledProduct();
+        ConsumerInstalledProduct installedProd2 = createConsumerInstalledProduct();
+        Consumer consumer = createConsumer(owner, null, null, null, null, List.of(installedProd1,
+            installedProd2));
+
+        List<ConsumerFeed> consumerFeed = rhsmApiCompatCurator.getConsumerFeed(owner, null, null, null, 1,
+            100);
+
+        List<ConsumerInstalledProduct> list = consumerFeed.get(0).getInstalledProducts();
+        assertThat(list)
+            .extracting(ConsumerInstalledProduct::getProductId)
+            .containsExactlyInAnyOrder(installedProd1.getProductId(), installedProd2.getProductId());
+        assertThat(list)
+            .extracting(ConsumerInstalledProduct::getProductName)
+            .contains(installedProd1.getProductName(), installedProd2.getProductName());
+    }
+
+    private Consumer createConsumer(Owner owner, String uuid, Date lastCheckin, Map<String, String> facts,
+        Set<String> addons, List<ConsumerInstalledProduct> installedProducts) {
+        Consumer consumer = new Consumer().setOwner(owner).setName("test-consumer")
+            .setType(this.createConsumerType()).setUuid(uuid).setLastCheckin(lastCheckin).setFacts(facts)
+            .setAddOns(addons).setInstalledProducts(installedProducts);
+
+        return this.consumerCurator.create(consumer);
+    }
+
+    private ConsumerInstalledProduct createConsumerInstalledProduct() {
+        ConsumerInstalledProduct source = new ConsumerInstalledProduct();
+
+        source.setProductId(TestUtil.randomString("test_product_id"));
+        source.setProductName(TestUtil.randomString("test_product_name"));
+        source.setVersion(TestUtil.randomString("test_version"));
+        source.setArch(TestUtil.randomString("test_arch"));
+        source.setStatus(TestUtil.randomString("test_status"));
+        source.setStartDate(new Date());
+        source.setEndDate(new Date());
+        source.setCreated(new Date());
+        source.setUpdated(new Date());
+
+        return source;
+    }
+
+}
diff --git a/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/src/test/java/org/candlepin/test/DatabaseTestFixture.java
index 7a16c9c84..2ae8c424c 100755
--- a/src/test/java/org/candlepin/test/DatabaseTestFixture.java
+++ b/src/test/java/org/candlepin/test/DatabaseTestFixture.java
@@ -79,6 +79,7 @@ import org.candlepin.model.Product;
 import org.candlepin.model.ProductCertificateCurator;
 import org.candlepin.model.ProductContent;
 import org.candlepin.model.ProductCurator;
+import org.candlepin.model.RhsmApiCompatCurator;
 import org.candlepin.model.Role;
 import org.candlepin.model.RoleCurator;
 import org.candlepin.model.RulesCurator;
@@ -177,6 +178,7 @@ public class DatabaseTestFixture {
     protected ProductCertificateCurator productCertificateCurator;
     protected ProductCurator productCurator;
     protected PoolCurator poolCurator;
+    protected RhsmApiCompatCurator rhsmApiCompatCurator;
     protected RoleCurator roleCurator;
     protected RulesCurator rulesCurator;
     protected SubscriptionsCertificateCurator subscriptionsCertificateCurator;
@@ -310,6 +312,7 @@ public class DatabaseTestFixture {
         productCertificateCurator = this.injector.getInstance(ProductCertificateCurator.class);
         productCurator = this.injector.getInstance(ProductCurator.class);
         poolCurator = this.injector.getInstance(PoolCurator.class);
+        rhsmApiCompatCurator = this.injector.getInstance(RhsmApiCompatCurator.class);
         roleCurator = this.injector.getInstance(RoleCurator.class);
         rulesCurator = this.injector.getInstance(RulesCurator.class);
         subscriptionsCertificateCurator = this.injector.getInstance(SubscriptionsCertificateCurator.class);
diff --git a/src/test/java/org/candlepin/util/ConsumerFeedFactExtractorTest.java b/src/test/java/org/candlepin/util/ConsumerFeedFactExtractorTest.java
new file mode 100644
index 000000000..4a6bb3d52
--- /dev/null
+++ b/src/test/java/org/candlepin/util/ConsumerFeedFactExtractorTest.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2009 - 2025 Red Hat, Inc.
+ *
+ * This software is licensed to you under the GNU General Public License,
+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or
+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
+ * along with this software; if not, see
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * Red Hat trademarks are not licensed under GPLv2. No permission is
+ * granted to use or replicate Red Hat trademarks that are incorporated
+ * in this software or its documentation.
+ */
+
+package org.candlepin.util;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class ConsumerFeedFactExtractorTest {
+
+    @Nested
+    @DisplayName("Direct allowed keys")
+    class AllowedKeyTests {
+        @ParameterizedTest
+        @ValueSource(strings = {
+            "cpu.cpu(s)",
+            "cpu.cpu_socket(s)",
+            "cpu.thread(s)_per_core",
+            "distribution.version",
+            "network.fqdn",
+            "bios.version",
+            "dmi.bios.vendor",
+            "network.hostname",
+            "dmi.system.manufacturer",
+            "dmi.system.product_name",
+            "insights_id",
+            "conversions.activity",
+            "dmi.system.uuid",
+            "uname.nodename",
+            "distribution.name",
+            "memory.memtotal",
+            "cpu.core(s)_per_socket",
+            "uname.machine",
+            "network.ipv6_address",
+            "dmi.chassis.asset_tag",
+            "dmi.bios.version",
+            "virt.is_guest",
+            "band.storage.usage",
+            "network.ipv4_address"
+        })
+        void extractsDirectAllowedKey(String key) {
+            Map<String, String> facts = Map.of(key, "xval");
+
+            Map<String, String> result = ConsumerFeedFactExtractor.extractRelevantFacts(facts);
+
+            assertEquals(1, result.size());
+            assertEquals("xval", result.get(key));
+        }
+    }
+
+    @Nested
+    @DisplayName("Allowed regex keys")
+    class AllowedRegexKeyTests {
+        @ParameterizedTest
+        @ValueSource(strings = {
+            "net.interface.eth0.mac_address",
+            "net.interface.eth9.ipv4_address",
+            "net.interface.lo.ipv6_address.global",
+            "net.interface.test.ipv6_address.link",
+            "net.interface.eno1.ipv4_address_list",
+            "net.interface.wlan0.ipv6_address.global_list",
+            "net.interface.wlan0.pv6_address.link_list",
+            "ocm.units",
+            "openshift.node",
+            "azure_foo",
+            "aws_123",
+            "gcp_test"
+        })
+        void extractsAllowedRegexKey(String key) {
+            Map<String, String> facts = Map.of(key, "regexval");
+
+            Map<String, String> result = ConsumerFeedFactExtractor.extractRelevantFacts(facts);
+
+            assertEquals(1, result.size());
+            assertEquals("regexval", result.get(key));
+        }
+    }
+
+    @Test
+    void ignoresNonMatchingKey() {
+        Map<String, String> facts = Map.of("unrelated.key", "nope");
+
+        Map<String, String> result = ConsumerFeedFactExtractor.extractRelevantFacts(facts);
+
+        assertTrue(result.isEmpty());
+    }
+
+    @Test
+    void doesNotDuplicateKeyWhenMatchesBothDirectAndRegex() {
+        // This situation shouldn't normally occur, but for 100% branch coverage:
+        String key = "network.ipv4_address"; // direct match, but also matches regex
+        Map<String, String> facts = Map.of(key, "foobar");
+
+        Map<String, String> result = ConsumerFeedFactExtractor.extractRelevantFacts(facts);
+
+        // It should appear exactly once, with the correct value
+        assertEquals(1, result.size());
+        assertEquals("foobar", result.get(key));
+    }
+
+    @Test
+    void preservesNullAndEmptyValues() {
+        Map<String, String> facts = new HashMap<>();
+        facts.put("distribution.version", null);
+        facts.put("cpu.cpu_socket(s)", "");
+
+        Map<String, String> result = ConsumerFeedFactExtractor.extractRelevantFacts(facts);
+
+        assertEquals(2, result.size());
+        assertNull(result.get("distribution.version"));
+        assertEquals("", result.get("cpu.cpu_socket(s)"));
+    }
+
+    @Test
+    void handlesEmptyInput() {
+        Map<String, String> facts = new HashMap<>();
+
+        Map<String, String> result = ConsumerFeedFactExtractor.extractRelevantFacts(facts);
+
+        assertTrue(result.isEmpty());
+    }
+
+    @Test
+    void mixedInput() {
+        Map<String, String> facts = new HashMap<>();
+        facts.put("cpu.cpu_socket(s)", "2"); // direct
+        facts.put("net.interface.eth0.mac_address", "AB:CD:EF:00:11:22"); // regex
+        facts.put("unrelated", "ignore"); // not allowed
+
+        Map<String, String> result = ConsumerFeedFactExtractor.extractRelevantFacts(facts);
+
+        assertEquals(2, result.size());
+        assertEquals("2", result.get("cpu.cpu_socket(s)"));
+        assertEquals("AB:CD:EF:00:11:22", result.get("net.interface.eth0.mac_address"));
+        assertFalse(result.containsKey("unrelated"));
+    }
+}
-- 
2.39.5 (Apple Git-154)

